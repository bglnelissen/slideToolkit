#!/bin/bash
#
# Description: Create macro and mask from virtual slide
# Copyright (C) 2014, B.G.L. Nelissen. All rights reserved.
#
#
# License here
#
# Respect the Google Shell style guide.
# http://google-styleguide.googlecode.com/svn/trunk/shell.xml

# Variables
SCRIPTNAME=$(basename $0)
DESCRIPTIONSHORT="Create macro and mask from virtual slide"
DEPENDENCIES=("convert" "parallel")
MASKSUFFIX_DEFAULT=".mask"
MACROSUFFIX_DEFAULT=".macro"
MACRO_THUMBSIZE="2000x2000" # Maximum size of macro image
# Errors go to stderr
err() {
  echo "ERROR: $@" >&2
}
# usage message
usage() {
cat <<- EOF
usage:  $SCRIPTNAME [options] [path/]file
        [--help]
EOF
}
# help message
helpMessage() {
cat <<- EOF
${SCRIPTNAME}: ${DESCRIPTIONSHORT}

$(usage)

options:
  -f, --file[=FILE]         virtual slide to create mask from
  --masksuffix[=TEXT]       mask suffix [DEFAULT="$MASKSUFFIX_DEFAULT"]
  --macrosuffix[=TEXT]      macro suffix [DEFAULT="$MACROSUFFIX_DEFAULT"]
  -l, --layer[=INT]         force specific layer by layer id [DEFAULT="$LAYER_DEFAULT"]

  --help                    display this help and exit

examples:
  $SCRIPTNAME "file.tif"
  $SCRIPTNAME  --file="file.tif"

multiple files at once:
  find -L ./ -name "*tif" | parallel $SCRIPTNAME "{}"

HPC qsub job submission:
  for i in \$(find -L ./ -name "*tif"); do
    j="\$(echo "\$(cd "\$(dirname "\$i")"; pwd)"/"\$(basename "\$i")")"; \\
    echo "qsub" -pe threaded 1 -q veryshort \\
    "$(command -v "$SCRIPTNAME")" --file="\${j}"
  done

dependencies: ${DEPENDENCIES[@]}

Sometimes not all tissue on your virtual slide needs processing. You can
mask parts of your image that you do not wat to process. This program
will automatically create a mask for you which you can later edit if
needed. The slideToolkit only excludes real black (color #000000). Two
new files will be created, one file.macro.png and one file.mask.png.
Existing files will be overwritten.

Report bugs to <b.g.l.nelissen@gmail.com>
slideToolkit (C) 2014, B.G.L. Nelissen
EOF
}
# Menu
# Empty variables
FILE=""
LAYER=""
MASKSUFFIX=""
MACROSUFFIX=""

# illegal option
illegalOption() {
cat <<- EOF
$SCRIPTNAME: illegal option $1
$(usage)
EOF
exit 1
}
# loop through options
while :
do
  case $1 in
    --help | -\?)
      helpMessage
      exit 0 ;;
    -f | --file)
      FILE=$2
      shift 2 ;;
    --file=*)
      FILE=${1#*=}
      shift ;;
    -l | --layer)
      LAYER=$2
      shift 2 ;;
    --layer=*)
      LAYER=${1#*=}
      shift ;;
    --masksuffix)
      MASKSUFFIX=$2
      shift 2 ;;
    --masksuffix=*)
      MASKSUFFIX=${1#*=}
      shift ;;
    --macrosuffix)
      MACROSUFFIX=$2
      shift 2 ;;
    --macrosuffix=*)
      MACROSUFFIX=${1#*=}
      shift ;;
    --) # End of all options
      shift
      break ;;
    -*)
      illegalOption "$1"
      shift ;;
    *)  # no more options. Stop while loop
      break ;;
  esac
done
# DEFAULTS
# set FILE
if [ "$FILE" != "" ]; then
  FILE="$FILE"
else
  FILE="$1"
fi
# set MASKSUFFIX default
if [ "$MASKSUFFIX" != "" ]; then
  MASKSUFFIX="$MASKSUFFIX"
else
  MASKSUFFIX="$MASKSUFFIX_DEFAULT"
fi
# set MACROSUFFIX default
if [ "$MACROSUFFIX" != "" ]; then
  MACROSUFFIX="$MACROSUFFIX"
else
  MACROSUFFIX="$MACROSUFFIX_DEFAULT"
fi
# set LAYER default
if [ "$LAYER" != "" ]; then
  LAYER="$LAYER"
else
  LAYER="$LAYER_DEFAULT"
fi

# requirements
checkRequirements() {
  if ! [[ -f "$FILE" ]] ; then
    err "No such file: $FILE"
    usage
    exit 1
  fi
}

# Dependencies
checkDependencies(){
  DEPENDENCIES="$DEPENDENCIES"
  DEPS=""
  for DEP in $DEPENDENCIES; do
    if [[ 0 != $(command -v "$DEP" >/dev/null ;echo $?) ]]; then
      DEPS=$(echo "$DEPS $DEP") # create `array` with unknown dependencies
    fi
  done
  if [[ "" != $(echo "$DEPS" | perl -p -e 's/ //g') ]]; then
    for d in $DEPS; do
      echo "Missing dependency: \"$d\""
    done
    exit 1
  fi
}

# get mask function for each type of scanner
getThumbiScanHT(){
  if [ "$LAYER" != "" ]; then
    LAYER="$LAYER"
  else
    # layer 8 contains the macro
    LAYER=8
  fi
	convert "$FILEFULL[$LAYER]" -resize "${MACRO_THUMBSIZE}>" -fuzz 1% -transparent "#ECECEC"  "$MACRO"
}
macroOlympusDP71(){
  if [ "$LAYER" != "" ]; then
    LAYER="$LAYER"
  else
    # layer 0 contains the macro
    LAYER=0
  fi
	convert "$FILEFULL[$LAYER]" -resize "${MACRO_THUMBSIZE}>" -fuzz 1% -transparent "#ECECEC"  "$MACRO"
}


# actual program
programOutput(){
  # set variables
  LAYER="$LAYER"
  FILEFULL="$(echo $(cd $(dirname $FILE); pwd)/$(basename $FILE))" # full path $FULL
  BASENAME=$(basename "$FILEFULL")    # basename
  EXTENSION="${BASENAME##*.}"         # extension
  FILEPATH="${FILEFULL%.*}"           # full path, no extension
  FILENAME="${BASENAME%.*}"           # filename, no extension"
  MASK="${FILEPATH}${MASKSUFFIX}.png"
  MACRO="${FILEPATH}${MACROSUFFIX}.png"

  # create macro
  # check metadata for scanner data
  if [[ "0" < "$(tiffinfo  "$FILEFULL" | strings | grep "iScanHT" | wc -l)" ]]; then
    getThumbiScanHT # iScanHT found
  elif [[ "0" < "$(tiffinfo  "$FILEFULL" | strings | grep "DP71" | wc -l)" ]]; then
    macroOlympusDP71  # Aperio found
  else
    err "Unknown virtual slide format: $FILEFULL"
    usage
    exit 1
  fi
  
  # create mask
  # a fuzz of 3% works well, but fails on very light slides
  # a fuzz of 2% is mightby to easy on the selection
  # a fuzz of 2.5% is possible (but still to stringend on some slides)
  #	 - add a border so blur works on the whole image
  #	 - blur the image to fill small holes (blur is slow, but necessary)
  #	 - make all white transparent (background)
  #	 - remove the border
  #	 - create alpha and save file
  convert "$MACRO" \( "$MACRO" \
    -bordercolor white -border 100x100 \
    -blur 40x40 \
    -fuzz 2% -transparent white \
    -crop +100+100 -crop -100-100 +repage \
    -alpha extract -transparent white \) \
    -flatten "$MASK"
}
# all check?
checkRequirements
checkDependencies 

# lets go!
# actual program
programOutput